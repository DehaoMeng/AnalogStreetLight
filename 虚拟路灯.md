# 一个典型物联网系统中传输机制的设计与实现

## (1)题目背景

一般一个典型的物联网系统包括感控层（传感器），网络层和应用层组成，而网络层主 要用于实现感控对象与应用层的服务对象之间的通信。本次作业就以 TCP/IP 协议栈中传输 层协议的应用开发为目标，以 UDP 方式实现一种感控对象与服务对象之间的通信机制，其 体系结构如图 1 所示。其中感控对象为一个虚拟路灯对象，在实现过程中用随机数模拟其温 度、湿度和环境照度等感知数据，灯作为被控对象，可以通过服务器对其进行打开、关闭控 制，且用不同颜色表示其开关状态。每个虚拟路灯都将有一个标识，以示区别。而服务对象 可以同时与若干个虚拟路灯对象通信，每个虚拟路灯会定期向服务对象发送其当前状态，服 务对象可以对任一个虚拟路灯进行开关控制。

![image-20220705200434525](E:\ujs_meng\计算机网络\虚拟路灯\虚拟路灯.assets\image-20220705200434525.png)

## (2)题目要求

（1）虚拟路灯状态上传数据直接基于 UDP 实现传输，不考了可靠性，而服务对象发送 给各虚拟路灯的开关命令要利用握手机制实现可靠传输。 

（2）基于 UDP 自定义上传、下发数据包格式和传输方式。并实现通信协议的定义、封 装和解析。

（3）不限定编程语言。

## (3)使用工具

Pycharm、Python、socket、tkinter、PyQt5

## (4)设计思路

### 客户端

客户端即路灯，用户输入温度、湿度、亮度等点击发送至服务端

![image-20220707125930102](E:\ujs_meng\计算机网络\虚拟路灯\虚拟路灯.assets\image-20220707125930102.png)

图1 PyQt实现界面

![image-20220707130026338](E:\ujs_meng\计算机网络\虚拟路灯\虚拟路灯.assets\image-20220707130026338.png)

图二  tkinter的界面

### 服务端

用于接受处理路灯发送来的环境状态，返回对灯的开关处理。

## (5)源码

udp_Server.py

~~~pyt
import socket

def main():
	# 创建套接字
	udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) # udp IPV4			tcp  IPV4
	# 绑定本地信息
	udp_socket.bind(('',8000))
	# 创建循环事件,为了使能不断接收数据。。。。。。。客户端只要发消息 我就能收到。
	while 1:
		# 接收终端的数据
		recv_data_T,address = udp_socket.recvfrom(1024)		# 接收温度
		recv_data_W,address = udp_socket.recvfrom(1024)		# 接收湿度
		recv_data_L,address = udp_socket.recvfrom(1024) 	# 接收环境照度

		# 退出数据传送判断
		# if not recv_data_T_A:
		if recv_data_T == b'#' or recv_data_W == b'#' or recv_data_L == b'#':
			break
		#判断是否满足开灯条件
		elif recv_data_T == b'20' and recv_data_L == b'5' and recv_data_W == b'25':
			udp_socket.sendto(b"open",address)
		elif recv_data_T != b'20' or recv_data_L != b'5' or recv_data_W != b'25':
			udp_socket.sendto(b"close",address)
		
	# 关闭套接字
	udp_socket.close()

if __name__ == "__main__":
	main()
~~~

PyQt的实现界面

Client.py

~~~python
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Client.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
LocalHost = "服务端ip地址"
import socket
import sys

from PyQt5 import QtCore, QtGui, QtWidgets
class Client:
    client_socket = None

    def __init__(self):
        self.initialize_socket()

    def initialize_socket(self):
        # 创建套接字
        self.clientsocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.setWindowModality(QtCore.Qt.ApplicationModal)
        Dialog.resize(457, 304)
        self.labelstatus = QtWidgets.QLabel(Dialog)
        self.labelstatus.setGeometry(QtCore.QRect(20, 40, 111, 51))
        self.labelstatus.setTextFormat(QtCore.Qt.PlainText)
        self.labelstatus.setScaledContents(False)
        self.labelstatus.setAlignment(QtCore.Qt.AlignCenter)
        self.labelstatus.setWordWrap(False)
        self.labelstatus.setObjectName("labelstatus")
        self.labelStatus = QtWidgets.QLabel(Dialog)
        self.labelStatus.setGeometry(QtCore.QRect(160, 50, 101, 31))
        self.labelStatus.setText("")
        self.labelStatus.setAlignment(QtCore.Qt.AlignCenter)
        self.labelStatus.setObjectName("labelStatus")
        self.labelStatus2 = QtWidgets.QLabel(Dialog)
        self.labelStatus2.setGeometry(QtCore.QRect(40, 80, 101, 61))
        self.labelStatus2.setTextFormat(QtCore.Qt.AutoText)
        self.labelStatus2.setAlignment(QtCore.Qt.AlignCenter)
        self.labelStatus2.setObjectName("labelStatus2")
        self.labelTem = QtWidgets.QLabel(Dialog)
        self.labelTem.setGeometry(QtCore.QRect(90, 150, 72, 15))
        self.labelTem.setObjectName("labelTem")
        self.labelWet = QtWidgets.QLabel(Dialog)
        self.labelWet.setGeometry(QtCore.QRect(90, 190, 72, 15))
        self.labelWet.setObjectName("labelWet")
        self.labelLight = QtWidgets.QLabel(Dialog)
        self.labelLight.setGeometry(QtCore.QRect(90, 230, 72, 15))
        self.labelLight.setObjectName("labelLight")
        self.lineEditTem = QtWidgets.QLineEdit(Dialog)
        self.lineEditTem.setGeometry(QtCore.QRect(140, 150, 101, 21))
        self.lineEditTem.setObjectName("lineEditTem")
        self.lineEditWet = QtWidgets.QLineEdit(Dialog)
        self.lineEditWet.setGeometry(QtCore.QRect(140, 190, 101, 21))
        self.lineEditWet.setObjectName("lineEditWet")
        self.lineEditLight = QtWidgets.QLineEdit(Dialog)
        self.lineEditLight.setGeometry(QtCore.QRect(140, 230, 101, 21))
        self.lineEditLight.setObjectName("lineEditLight")
        self.pushButton = QtWidgets.QPushButton(Dialog)
        self.pushButton.setGeometry(QtCore.QRect(300, 120, 111, 71))
        self.pushButton.setObjectName("pushButton")

        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Ludeng"))
        self.labelstatus.setText(_translate("Dialog", "路灯状态："))
        self.labelStatus2.setText(_translate("Dialog", "环境状态："))
        self.labelTem.setText(_translate("Dialog", "温度："))
        self.labelWet.setText(_translate("Dialog", "湿度："))
        self.labelLight.setText(_translate("Dialog", "亮度："))
        self.pushButton.setText(_translate("Dialog", "发送"))
        self.pushButton.clicked.connect(self.SendMessage)

    def SendMessage(self):
        self.client = Client()
        self.client.initialize_socket()
        data_t = self.labelTem.text()
        data_w = self.labelWet.text()
        data_l = self.labelLight.text()
        self.client.clientsocket.sendto(data_t.encode("utf8"), (LocalHost, 8000))
        self.client.clientsocket.sendto(data_w.encode("utf8"), (LocalHost, 8000))
        self.client.clientsocket.sendto(data_l.encode("utf8"), (LocalHost, 8000))
        if data_l == '#' or data_w == 'w' or data_t == '#':
            exit(0)
        self.recvfrom_server()

    def recvfrom_server(self):
        self.status, self.address = self.client.clientsocket.recvfrom(1024)
        if self.status == b'open':
            self.labelStatus.setText("Open")
        else:
            self.labelStatus.setText("Close")

if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_Dialog()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
~~~

tkinter实现路灯界面

udp_Client.py

~~~pyt
# -*- coding: utf-8 -*-

import socket
from tkinter import Tk, Frame, Scrollbar, Label, END, Entry, Text, VERTICAL, Button, messagebox
LocalHost = "服务端ip地址"

class Client:
    client_socket = None

    def __init__(self):
        self.initialize_socket()

    def initialize_socket(self):
        # 创建套接字
        self.clientsocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)


class Gui:
    def __init__(self, master):
        self.root = master
        self.height = 200
        self.width = 450
        self.client = Client()
        self.initialize_gui()  # 图形化界面

    def initialize_gui(self):
        self.root.title("终端")  # 初始化
        self.root.resizable(0, 0)
        self.root.geometry("900x600")
        self.status()
        self.display_light_a()
        self.display_light_b()
        self.display_light_c()


    def status(self):
        Label(self.root, text=" 路灯终端A ", font=('heiti', 15), width=10, height=2).place(x=100, y=50)
        Label(self.root, text=" 状 态  ", font=('heiti', 30), width=7, height=2).place(x=200, y=37)
        Label(self.root, text=" 路灯终端B ", font=('heiti', 15), width=10, height=2).place(x=100, y=250)
        Label(self.root, text=" 状 态", font=('heiti', 30), width=7, height=2).place(x=200, y=237)
        Label(self.root, text=" 状 态", font=('heiti', 30), width=7, height=2).place(x=200, y=437)
        Label(self.root, text=" 路灯终端C ", font=('heiti', 15), width=10, height=2).place(x=100, y=450)
        # def server(self):
        # Button(self.root,text=" 开 始 服 务",font=('heiti',8),width=13,height=1,relief="groove").place(x=10,y=10)
        # Button(self.root,text=" 终 止 服 务 ",font=('heiti',8),width=13,height=1,relief="groove").place(x=10,y=27)


    def display_light_a(self):
        frame = Frame(self.root, height=self.height, width=self.width, bd=20, relief="groove")
        frame.place(x=450, y=0)
        Label(frame, text=" 温度：", font=('heiti', 15), width=5, height=2).place(x=10, y=15)
        Label(frame, text=" 湿度：", font=('heiti', 15), width=5, height=2).place(x=10, y=55)
        Label(frame, text=" 亮度：", font=('heiti', 15), width=5, height=2).place(x=10, y=95)
        self.t_a = Entry(frame, width=10)
        self.t_a.place(x=60, y=30)
        self.w_a = Entry(frame, width=10)
        self.w_a.place(x=60, y=70)
        self.l_a = Entry(frame, width=10)
        self.l_a.place(x=60, y=110)
        Button(frame, text=" 上 传 数 据", font=('heiti', 8), width=13, height=2, relief="groove",
               command=lambda: self.send_message(self.t_a, self.w_a, self.l_a, frame)).place(x=200, y=55)
        # self.status_light()
        # 接收数据
        # 根据收到的数据改变当前状态
        # Label(frame,text=" 状态：",font=('heiti',30),width=7,height=2).place(x=200,y=37)
        # Entry(frame,width=4).place(x=310,y=75)


    def display_light_b(self):
        frame = Frame(self.root, height=self.height, width=self.width, bd=20, relief="groove")
        frame.place(x=450, y=200)
        Label(frame, text=" 温度：", font=('heiti', 15), width=5, height=2).place(x=10, y=15)
        Label(frame, text=" 湿度：", font=('heiti', 15), width=5, height=2).place(x=10, y=55)
        Label(frame, text=" 亮度：", font=('heiti', 15), width=5, height=2).place(x=10, y=95)
        self.t_b = Entry(frame, width=10)
        self.t_b.place(x=60, y=30)
        self.w_b = Entry(frame, width=10)
        self.w_b.place(x=60, y=70)
        self.l_b = Entry(frame, width=10)
        self.l_b.place(x=60, y=110)
        Button(frame, text=" 上 传 数 据", font=('heiti', 8), width=13, height=2, relief="groove",
               command=lambda: self.send_message(self.t_b, self.w_b, self.l_b, frame)).place(x=200, y=55)
        # 接收数据
        # 根据收到的数据改变当前状态
        # Label(frame,text=" 状态：",font=('heiti',30),width=7,height=2).place(x=200,y=37)
        # Entry(frame,width=4).place(x=310,y=75)


    def display_light_c(self):
        frame = Frame(self.root, height=self.height, width=self.width, bd=20, relief="groove")
        frame.place(x=450, y=400)
        Label(frame, text=" 温度：", font=('heiti', 15), width=5, height=2).place(x=10, y=15)
        Label(frame, text=" 湿度：", font=('heiti', 15), width=5, height=2).place(x=10, y=55)
        Label(frame, text=" 亮度：", font=('heiti', 15), width=5, height=2).place(x=10, y=95)
        self.t_c = Entry(frame, width=10)
        self.t_c.place(x=60, y=30)
        self.w_c = Entry(frame, width=10)
        self.w_c.place(x=60, y=70)
        self.l_c = Entry(frame, width=10)
        self.l_c.place(x=60, y=110)
        Button(frame, text=" 上 传 数 据", font=('heiti', 8), width=13, height=2, relief="groove", command=lambda: self.send_message(self.t_c, self.w_c, self.l_c, frame)).place(x=200, y=55)
        # Label(frame,text=" 状态：",font=('heiti',30),width=7,height=2).place(x=200,y=37)


    def recvfrom_server(self, frame):
        self.status, self.address = self.client.clientsocket.recvfrom(1024)
        if self.status == b'open':
            Label(frame, text="OPEN", font=('heiti', 10), width=5, height=2, relief="groove").place(x=300, y=55)
        else:
            Label(frame, text="CLOSE", font=('heiti', 10), width=5, height=2, relief="groove").place(x=300, y=55)


    def send_message(self, t, w, l, frame):
        self.client.initialize_socket()
        data_t = t.get()
        # print(data_t)
        data_w = w.get()
        data_l = l.get()
        self.client.clientsocket.sendto(data_t.encode("utf8"), (LocalHost, 8000))
        self.client.clientsocket.sendto(data_w.encode("utf8"), (LocalHost, 8000))
        self.client.clientsocket.sendto(data_l.encode("utf8"), (LocalHost, 8000))
        if data_l == '#' or data_w == 'w' or data_t == '#':
            self.on_close_window()
        self.recvfrom_server(frame)


    def on_close_window(self):
        if messagebox.askokcancel("退出", "确定退出吗?"):
            self.root.destroy()
            self.client.clientsocket.close()
            exit(0)


if __name__ == "__main__":
    root = Tk()
    gui = Gui(root)
    root.protocol("WM_DELETE_WINDOW", gui.on_close_window)
    root.mainloop()
~~~

## (6)GitHub查看

GitHub：https://github.com/ITApeDeHao/AnalogStreetLight
